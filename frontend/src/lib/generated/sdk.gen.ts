// This file is auto-generated by @hey-api/openapi-ts

import { type Client, formDataBodySerializer, type Options as Options2, type TDataShape, urlSearchParamsBodySerializer } from './client';
import { client } from './client.gen';
import { jobsInfoResponseTransformer, usersGetAllTokenInfoResponseTransformer } from './transformers.gen';
import type { AdminsAddSiteBannerData, AdminsAddSiteBannerErrors, AdminsAddSiteBannerResponses, AdminsCreateRunnerData, AdminsCreateRunnerErrors, AdminsCreateRunnerResponses, AdminsDeleteSiteBannerData, AdminsDeleteSiteBannerErrors, AdminsDeleteSiteBannerResponses, AdminsInvalidateRunnerData, AdminsInvalidateRunnerErrors, AdminsInvalidateRunnerResponses, AdminsSendEmailToAllUsersData, AdminsSendEmailToAllUsersErrors, AdminsSendEmailToAllUsersResponses, GeneralAboutData, GeneralAboutResponses, GeneralAuthSettingsData, GeneralAuthSettingsResponses, JobsAbortData, JobsAbortErrors, JobsAbortResponses, JobsCountData, JobsCountErrors, JobsCountResponses, JobsDefaultSettingsData, JobsDefaultSettingsErrors, JobsDefaultSettingsResponses, JobsDeleteData, JobsDeleteErrors, JobsDeleteResponses, JobsDownloadTranscriptData, JobsDownloadTranscriptErrors, JobsDownloadTranscriptResponses, JobsEventsData, JobsEventsErrors, JobsEventsResponses, JobsGetData, JobsGetErrors, JobsGetResponses, JobsInfoData, JobsInfoErrors, JobsInfoResponses, JobsSubmitJobData, JobsSubmitJobErrors, JobsSubmitJobResponses, JobsSubmitSettingsData, JobsSubmitSettingsErrors, JobsSubmitSettingsResponses, LdapLoginData, LdapLoginErrors, LdapLoginResponses, LocalAccountActivateData, LocalAccountActivateErrors, LocalAccountActivateResponses, LocalAccountChangeUserEmailData, LocalAccountChangeUserEmailErrors, LocalAccountChangeUserEmailResponses, LocalAccountChangeUserPasswordData, LocalAccountChangeUserPasswordErrors, LocalAccountChangeUserPasswordResponses, LocalAccountLoginData, LocalAccountLoginErrors, LocalAccountLoginResponses, LocalAccountRequestPasswordResetData, LocalAccountRequestPasswordResetErrors, LocalAccountRequestPasswordResetResponses, LocalAccountResendActivationEmailData, LocalAccountResendActivationEmailErrors, LocalAccountResendActivationEmailResponses, LocalAccountResetPasswordData, LocalAccountResetPasswordErrors, LocalAccountResetPasswordResponses, LocalAccountSignupData, LocalAccountSignupErrors, LocalAccountSignupResponses, OidcOidcAuthData, OidcOidcAuthErrors, OidcOidcAuthResponses, OidcOidcRedirectData, OidcOidcRedirectErrors, OidcOidcRedirectResponses, RunnersHeartbeatData, RunnersHeartbeatErrors, RunnersHeartbeatResponses, RunnersRegisterData, RunnersRegisterErrors, RunnersRegisterResponses, RunnersRetrieveJobAudioData, RunnersRetrieveJobAudioErrors, RunnersRetrieveJobAudioResponses, RunnersRetrieveJobInfoData, RunnersRetrieveJobInfoErrors, RunnersRetrieveJobInfoResponses, RunnersSubmitJobResultData, RunnersSubmitJobResultErrors, RunnersSubmitJobResultResponses, RunnersUnregisterData, RunnersUnregisterErrors, RunnersUnregisterResponses, UsersAcceptTosData, UsersAcceptTosErrors, UsersAcceptTosResponses, UsersDeleteData, UsersDeleteErrors, UsersDeleteResponses, UsersGetAllTokenInfoData, UsersGetAllTokenInfoErrors, UsersGetAllTokenInfoResponses, UsersGetNewApiTokenData, UsersGetNewApiTokenErrors, UsersGetNewApiTokenResponses, UsersInfoData, UsersInfoErrors, UsersInfoResponses, UsersInvalidateAllTokensData, UsersInvalidateAllTokensErrors, UsersInvalidateAllTokensResponses, UsersInvalidateTokenData, UsersInvalidateTokenErrors, UsersInvalidateTokenResponses, UsersLogoutData, UsersLogoutErrors, UsersLogoutResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * About
 *
 * Returns a brief description of Project-W, a link to the GitHub repository containing the backend's code, the backend's version currently running on the system as well as the imprint of this instance (if it was configured by the instance's admin).
 */
export const generalAbout = <ThrowOnError extends boolean = false>(options?: Options<GeneralAboutData, ThrowOnError>) => (options?.client ?? client).get<GeneralAboutResponses, unknown, ThrowOnError>({ url: '/api/about', ...options });

/**
 * Auth Settings
 *
 * Returns all information required by the client regarding which account types and identity providers this instance supports, whether account signup of local accounts is allowed, whether the creation of API tokens is allowed for each account type and so on.
 */
export const generalAuthSettings = <ThrowOnError extends boolean = false>(options?: Options<GeneralAuthSettingsData, ThrowOnError>) => (options?.client ?? client).get<GeneralAuthSettingsResponses, unknown, ThrowOnError>({ url: '/api/auth_settings', ...options });

/**
 * Invalidate Token
 *
 * Invalidate the local token with the provided id. Doesn't work for OIDC tokens. After calling this route the token with the provided id can't be used anymore.
 */
export const usersInvalidateToken = <ThrowOnError extends boolean = false>(options: Options<UsersInvalidateTokenData, ThrowOnError>) => (options.client ?? client).delete<UsersInvalidateTokenResponses, UsersInvalidateTokenErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/users/invalidate_token',
    ...options
});

/**
 * Invalidate All Tokens
 *
 * Invalidate all local tokens of the logged in user account. Doesn't work for OIDC tokens. After calling this route all local tokens of the logged in user account won't work anymore.
 */
export const usersInvalidateAllTokens = <ThrowOnError extends boolean = false>(options?: Options<UsersInvalidateAllTokensData, ThrowOnError>) => (options?.client ?? client).delete<UsersInvalidateAllTokensResponses, UsersInvalidateAllTokensErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/users/invalidate_all_tokens',
    ...options
});

/**
 * Logout
 *
 * Like /invalidate_token, but invalidates the token currently being used and additionally unsets the token cookie
 */
export const usersLogout = <ThrowOnError extends boolean = false>(options?: Options<UsersLogoutData, ThrowOnError>) => (options?.client ?? client).delete<UsersLogoutResponses, UsersLogoutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/users/logout',
    ...options
});

/**
 * Get New Api Token
 *
 * Create a new API token. The main difference between API tokens and regular auth tokens is that API tokens never expire. Only create them if necessary and only use a different token for each device/service so that it is easy to invalidate one of them if a device gets compromised. The provided name has the purpose of being able to identify which token belongs to which device/service.THe successfully response contains the newly created token.
 */
export const usersGetNewApiToken = <ThrowOnError extends boolean = false>(options: Options<UsersGetNewApiTokenData, ThrowOnError>) => (options.client ?? client).post<UsersGetNewApiTokenResponses, UsersGetNewApiTokenErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/users/get_new_api_token',
    ...options
});

/**
 * Get All Token Info
 *
 * Get a list of all token id's and names currently in use by this account, sorted by last usage timestamp.
 */
export const usersGetAllTokenInfo = <ThrowOnError extends boolean = false>(options?: Options<UsersGetAllTokenInfoData, ThrowOnError>) => (options?.client ?? client).get<UsersGetAllTokenInfoResponses, UsersGetAllTokenInfoErrors, ThrowOnError>({
    responseTransformer: usersGetAllTokenInfoResponseTransformer,
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/users/get_all_token_info',
    ...options
});

/**
 * Info
 *
 * This route returns all information about the currently logged in user.
 */
export const usersInfo = <ThrowOnError extends boolean = false>(options?: Options<UsersInfoData, ThrowOnError>) => (options?.client ?? client).get<UsersInfoResponses, UsersInfoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/users/info',
    ...options
});

/**
 * Accept Tos
 *
 * By calling this route the user accepts to the terms of service specified by the submitted tos_id and tos_version. Only if a user has accepted the newest version of every term of service of this instance they are allowed to use this service.
 */
export const usersAcceptTos = <ThrowOnError extends boolean = false>(options: Options<UsersAcceptTosData, ThrowOnError>) => (options.client ?? client).post<UsersAcceptTosResponses, UsersAcceptTosErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/users/accept_tos',
    ...options
});

/**
 * Delete
 *
 * Deletes the currently logged in user and all information related to it (like jobs, tokens, etc.)
 */
export const usersDelete = <ThrowOnError extends boolean = false>(options?: Options<UsersDeleteData, ThrowOnError>) => (options?.client ?? client).delete<UsersDeleteResponses, UsersDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/users/delete',
    ...options
});

/**
 * Create Runner
 *
 * Create a new global runner that can be used by all users of this instance. Returns the id and the runner token of the newly created runner. Put this token into the config file of the runner that you are trying to host. Create a new runner token for each new runner that you want to host using this route!
 */
export const adminsCreateRunner = <ThrowOnError extends boolean = false>(options?: Options<AdminsCreateRunnerData, ThrowOnError>) => (options?.client ?? client).post<AdminsCreateRunnerResponses, AdminsCreateRunnerErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/admins/create_runner',
    ...options
});

/**
 * Invalidate Runner
 *
 * Invalidate the token of a runner and delete it from the database and redis. If it has any jobs assigned at the time of invalidation these jobs will be reassigned to a different runner. Call this route immediately ones you find out that a runner token was compromised!
 */
export const adminsInvalidateRunner = <ThrowOnError extends boolean = false>(options: Options<AdminsInvalidateRunnerData, ThrowOnError>) => (options.client ?? client).delete<AdminsInvalidateRunnerResponses, AdminsInvalidateRunnerErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/admins/invalidate_runner',
    ...options
});

/**
 * Add Site Banner
 *
 * Add a new banner to the website that will be broadcasted to all users. Returns the id of the created banner.
 * Banners with higher urgency will be displayed first. The text of a banner with an urgency between 100 and 200 (excluding) will be highlighted in red. Banners with an urgency of 200 and more will have a red background.
 */
export const adminsAddSiteBanner = <ThrowOnError extends boolean = false>(options: Options<AdminsAddSiteBannerData, ThrowOnError>) => (options.client ?? client).post<AdminsAddSiteBannerResponses, AdminsAddSiteBannerErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/admins/add_site_banner',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Site Banner
 */
export const adminsDeleteSiteBanner = <ThrowOnError extends boolean = false>(options: Options<AdminsDeleteSiteBannerData, ThrowOnError>) => (options.client ?? client).delete<AdminsDeleteSiteBannerResponses, AdminsDeleteSiteBannerErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/admins/delete_site_banner',
    ...options
});

/**
 * Send Email To All Users
 *
 * Sends out an email with the provided content to all users of this Project-W instance, regardless whether they are local accounts, oidc accounts or ldap accounts. The body is in plaintext format, don't forget to include line breaks for longer emails.
 */
export const adminsSendEmailToAllUsers = <ThrowOnError extends boolean = false>(options: Options<AdminsSendEmailToAllUsersData, ThrowOnError>) => (options.client ?? client).post<AdminsSendEmailToAllUsersResponses, AdminsSendEmailToAllUsersErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/admins/send_email_to_all_users',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Submit Settings
 *
 * Submit a new job settings object to the backend. If is_new_default is set to True this set of job settings will become the new default for this account and if no job settings object is specified during job submission this set of settings will be used. If it is set to False then this set of settings will only be used if specified explicitly during job submission. Returns the id of the newly created job settings object which can then be used to reference these job settings during job submission.
 */
export const jobsSubmitSettings = <ThrowOnError extends boolean = false>(options: Options<JobsSubmitSettingsData, ThrowOnError>) => (options.client ?? client).post<JobsSubmitSettingsResponses, JobsSubmitSettingsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/submit_settings',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Default Settings
 *
 * Returns the default job settings of the current account. If no job settings id is explicitly specified during job submission then these job settings will be used for the job. These job settings where either set previously using the submit_settings route or are the application defaults.
 */
export const jobsDefaultSettings = <ThrowOnError extends boolean = false>(options?: Options<JobsDefaultSettingsData, ThrowOnError>) => (options?.client ?? client).get<JobsDefaultSettingsResponses, JobsDefaultSettingsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/default_settings',
    ...options
});

/**
 * Submit Job
 *
 * Submit a new transcription job. If the job_settings_id is omitted the account defaults will be used.
 * If you want to define the job settings then create a job settings object using the submit_settings route and then set job_settings_id here to the returned integer.
 * Returns the id of the newly created job.
 */
export const jobsSubmitJob = <ThrowOnError extends boolean = false>(options: Options<JobsSubmitJobData, ThrowOnError>) => (options.client ?? client).post<JobsSubmitJobResponses, JobsSubmitJobErrors, ThrowOnError>({
    ...formDataBodySerializer,
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/submit_job',
    ...options,
    headers: {
        'Content-Type': null,
        ...options.headers
    }
});

/**
 * Count
 *
 * Returns the total amount of jobs this user has after applying the provided filter options.
 * exclude_finished excludes finished jobs (both successful and aborted) while exclude_downloaded excludes finished jobs where the transcript was already downloaded at least ones.
 */
export const jobsCount = <ThrowOnError extends boolean = false>(options: Options<JobsCountData, ThrowOnError>) => (options.client ?? client).get<JobsCountResponses, JobsCountErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/count',
    ...options
});

/**
 * Get
 *
 * Returns a list of job ids sorted and filtered by the specified criteria.
 * start_index and end_index specify which jobs to return from the sorted list, e.g. a start_index of 0 and end_index of 9 will return the first 10 jobs, while a start_index of 10 and and end_index of 19 will return the next 10 and so on.
 */
export const jobsGet = <ThrowOnError extends boolean = false>(options: Options<JobsGetData, ThrowOnError>) => (options.client ?? client).get<JobsGetResponses, JobsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/get',
    ...options
});

/**
 * Info
 *
 * Returns a list of job objects containing all information related to each of the specified jobs.
 * Note that job infos will be returned in no specific order, please use the get route to get an ordering of jobs by id and only use this route to get additional information about these jobs.
 */
export const jobsInfo = <ThrowOnError extends boolean = false>(options: Options<JobsInfoData, ThrowOnError>) => (options.client ?? client).get<JobsInfoResponses, JobsInfoErrors, ThrowOnError>({
    responseTransformer: jobsInfoResponseTransformer,
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/info',
    ...options
});

/**
 * Abort
 *
 * Aborts a currently running job. This will put the job into a failed state with an error message saying that the job was aborted. Any processing of this job will be canceled.
 */
export const jobsAbort = <ThrowOnError extends boolean = false>(options: Options<JobsAbortData, ThrowOnError>) => (options.client ?? client).post<JobsAbortResponses, JobsAbortErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/abort',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete
 *
 * Deletes a completed (aborted/successfully finished) job. To delete a currently running job please use the abort route first and then delete it using this route.
 */
export const jobsDelete = <ThrowOnError extends boolean = false>(options: Options<JobsDeleteData, ThrowOnError>) => (options.client ?? client).delete<JobsDeleteResponses, JobsDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Download Transcript
 *
 * Downloads the transcript of a successfully finished job. The transcript can be downloaded in multiple formats.
 * Returns the transcript as a string.
 */
export const jobsDownloadTranscript = <ThrowOnError extends boolean = false>(options: Options<JobsDownloadTranscriptData, ThrowOnError>) => (options.client ?? client).get<JobsDownloadTranscriptResponses, JobsDownloadTranscriptErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/download_transcript',
    ...options
});

/**
 * Events
 *
 * This is a special route for subscribing to server-sent events (SSE) which all contain an event field.
 * Currently there are three events: job_created, job_updated and job_deleted. As data they all return the job id of the job the event refers to (i.e. the id of the job that just got created, updated or deleted). This route can be used to only fetch job info using the info route when it actually has changed without having to periodically re-fetch the job info of all jobs. Refer to https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#listening_for_custom_events for more information about SSE.
 */
export const jobsEvents = <ThrowOnError extends boolean = false>(options?: Options<JobsEventsData, ThrowOnError>) => (options?.client ?? client).get<JobsEventsResponses, JobsEventsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/jobs/events',
    ...options
});

/**
 * Register
 *
 * Registers the runner with the given runner_id as online.
 * Starting from the registration, the runner must periodically send
 * heartbeat requests to the manager, or it may be unregistered.
 * Returns the runner id on success.
 */
export const runnersRegister = <ThrowOnError extends boolean = false>(options: Options<RunnersRegisterData, ThrowOnError>) => (options.client ?? client).post<RunnersRegisterResponses, RunnersRegisterErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/runners/register',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Unregister
 *
 * Unregisters an online runner. This will mark the runner as offline and no heartbeat or similar request will be possible anymore until another register request was performed.
 */
export const runnersUnregister = <ThrowOnError extends boolean = false>(options?: Options<RunnersUnregisterData, ThrowOnError>) => (options?.client ?? client).post<RunnersUnregisterResponses, RunnersUnregisterErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/runners/unregister',
    ...options
});

/**
 * Retrieve Job Info
 *
 * The runner can retrieve metadata about the job that was assigned to it. This includes e.g. the job settings. The runner should call this route BEFORE it calls retrieve_job_audio to first make sure it can process the job. retrieve_job_info doesn't mark the job as running yet, only retrieve_job_audio will do that.
 */
export const runnersRetrieveJobInfo = <ThrowOnError extends boolean = false>(options: Options<RunnersRetrieveJobInfoData, ThrowOnError>) => (options.client ?? client).get<RunnersRetrieveJobInfoResponses, RunnersRetrieveJobInfoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/runners/retrieve_job_info',
    ...options
});

/**
 * Retrieve Job Audio
 *
 * The runner streams the audio binary data of the job it got assigned over this route.
 * Additionally this route will mark the job a currently being processed by this runner.
 * Before calling this route the runner should have called retrieve_job_info first.
 */
export const runnersRetrieveJobAudio = <ThrowOnError extends boolean = false>(options: Options<RunnersRetrieveJobAudioData, ThrowOnError>) => (options.client ?? client).post<RunnersRetrieveJobAudioResponses, RunnersRetrieveJobAudioErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/runners/retrieve_job_audio',
    ...options
});

/**
 * Submit Job Result
 *
 * The runner submits the result of processing the job it got assigned over this route. The result can either be that the job failed (in which case the runner submits an error message) or that the job was successful (in which case the runner submits the transcript in all possible formats). This route will mark the job as failed or successful and notify the user over email if they activated email notifications for this job.
 */
export const runnersSubmitJobResult = <ThrowOnError extends boolean = false>(options: Options<RunnersSubmitJobResultData, ThrowOnError>) => (options.client ?? client).post<RunnersSubmitJobResultResponses, RunnersSubmitJobResultErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/runners/submit_job_result',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Heartbeat
 *
 * The heartbeat route that the runner has to periodically call to not be unregistered automatically by the backend. Over the response of this route the runner will also be notified about a new job that it got assigned or an abort request for a job the runner is currently processing.
 */
export const runnersHeartbeat = <ThrowOnError extends boolean = false>(options: Options<RunnersHeartbeatData, ThrowOnError>) => (options.client ?? client).post<RunnersHeartbeatResponses, RunnersHeartbeatErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/runners/heartbeat',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Oidc-Redirect
 *
 * Start an OIDC login flow. This route will redirect you to the login page of the identity provider 'idp_name'. This name was specified by the admin in the config of this instance. Use the /api/auth_settings route to get the authentication-related configuration of this instance.
 */
export const oidcOidcRedirect = <ThrowOnError extends boolean = false>(options: Options<OidcOidcRedirectData, ThrowOnError>) => (options.client ?? client).get<OidcOidcRedirectResponses, OidcOidcRedirectErrors, ThrowOnError>({ url: '/api/oidc/login/{idp_name}', ...options });

/**
 * Oidc-Auth
 *
 * Landing route: After authenticating on the login page of the identity provider the provider will redirect you to this route so that the backend can process the IdP's response. This route will then redirect you to the official client's page (as set by the instance's admin) so that the client can get and store the OIDC id_token.
 */
export const oidcOidcAuth = <ThrowOnError extends boolean = false>(options: Options<OidcOidcAuthData, ThrowOnError>) => (options.client ?? client).get<OidcOidcAuthResponses, OidcOidcAuthErrors, ThrowOnError>({ url: '/api/oidc/auth/{idp_name}', ...options });

/**
 * Login
 *
 * Log in with an LDAP user queried from the LDAP server with the name 'idp_name'. This name was specified by the admin in the config of this instance. Use the /api/auth_settings route to get the authentication-related configuration of this instance.
 * If logging in with an admin account the returned auth token will not give you admin privileges by default. If you need a token with admin privileges then specify the scope 'admin' during login.
 */
export const ldapLogin = <ThrowOnError extends boolean = false>(options: Options<LdapLoginData, ThrowOnError>) => (options.client ?? client).post<LdapLoginResponses, LdapLoginErrors, ThrowOnError>({
    ...urlSearchParamsBodySerializer,
    url: '/api/ldap/login/{idp_name}',
    ...options,
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        ...options.headers
    }
});

/**
 * Login
 *
 * Log in to an existing local Project-W account. This is an OAuth2 compliant password request form where the username is the user's email address. A successful response will contain a token that needs to be attached in the authentication header of responses for routes that require the user to be logged in.
 * If logging in with an admin account the returned auth token will not give you admin privileges by default. If you need a token with admin privileges then specify the scope 'admin' during login.
 */
export const localAccountLogin = <ThrowOnError extends boolean = false>(options: Options<LocalAccountLoginData, ThrowOnError>) => (options.client ?? client).post<LocalAccountLoginResponses, LocalAccountLoginErrors, ThrowOnError>({
    ...urlSearchParamsBodySerializer,
    url: '/api/local-account/login',
    ...options,
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        ...options.headers
    }
});

/**
 * Signup
 *
 * Create a new local Project-W account. The provided email must be valid and the password must adhere to certain criteria (must contain at least one lowercase letter, uppercase letter, number, special character and at least 12 characters in total) and the email can't already be in use by another account.
 */
export const localAccountSignup = <ThrowOnError extends boolean = false>(options: Options<LocalAccountSignupData, ThrowOnError>) => (options.client ?? client).post<LocalAccountSignupResponses, LocalAccountSignupErrors, ThrowOnError>({
    url: '/api/local-account/signup',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Activate
 *
 * Activate a local Project-W account, meaning validate it's email address. The token was sent to the user on account creation, email address change or when they specifically requested an email with the resend_activation_email route. Only activated users are able to submit transcription jobs and actually use this service.
 */
export const localAccountActivate = <ThrowOnError extends boolean = false>(options: Options<LocalAccountActivateData, ThrowOnError>) => (options.client ?? client).post<LocalAccountActivateResponses, LocalAccountActivateErrors, ThrowOnError>({ url: '/api/local-account/activate', ...options });

/**
 * Resend Activation Email
 *
 * This will resend an activation email to the user like the one the user got when their account was created. Useful if they forgot to click on the link and lost the old email. Can only be requested if the user is not verified yet.
 */
export const localAccountResendActivationEmail = <ThrowOnError extends boolean = false>(options?: Options<LocalAccountResendActivationEmailData, ThrowOnError>) => (options?.client ?? client).get<LocalAccountResendActivationEmailResponses, LocalAccountResendActivationEmailErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/local-account/resend_activation_email',
    ...options
});

/**
 * Request Password Reset
 *
 * Requests a password reset email that will be sent to the user containing a link to a password reset page. The provided email address must belong to an existing local Project-W account.
 */
export const localAccountRequestPasswordReset = <ThrowOnError extends boolean = false>(options: Options<LocalAccountRequestPasswordResetData, ThrowOnError>) => (options.client ?? client).get<LocalAccountRequestPasswordResetResponses, LocalAccountRequestPasswordResetErrors, ThrowOnError>({ url: '/api/local-account/request_password_reset', ...options });

/**
 * Reset Password
 *
 * Resets the password of an account to the provided password. The token is the one from the password reset email that can be requested with the /request_password_reset route.
 */
export const localAccountResetPassword = <ThrowOnError extends boolean = false>(options: Options<LocalAccountResetPasswordData, ThrowOnError>) => (options.client ?? client).post<LocalAccountResetPasswordResponses, LocalAccountResetPasswordErrors, ThrowOnError>({
    url: '/api/local-account/reset_password',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Change User Email
 *
 * Change the email address of a local Project-W account. This change will only take effect after the user has clicked on the link in the activation email that this route sends to the new email address.
 */
export const localAccountChangeUserEmail = <ThrowOnError extends boolean = false>(options: Options<LocalAccountChangeUserEmailData, ThrowOnError>) => (options.client ?? client).post<LocalAccountChangeUserEmailResponses, LocalAccountChangeUserEmailErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/local-account/change_user_email',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Change User Password
 *
 * Change the password of a local Project-W account. In contrary to requesting a password reset email this route is authenticated meaning that to use this route the user must still be able to log in into their account, but it changes the password immediately without going through a link in an email first.
 */
export const localAccountChangeUserPassword = <ThrowOnError extends boolean = false>(options: Options<LocalAccountChangeUserPasswordData, ThrowOnError>) => (options.client ?? client).post<LocalAccountChangeUserPasswordResponses, LocalAccountChangeUserPasswordErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }, {
            in: 'cookie',
            name: 'token',
            type: 'apiKey'
        }],
    url: '/api/local-account/change_user_password',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});
